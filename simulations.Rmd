---
title: "Simulations"
output:
  pdf_document: default
  html_document: default
date: "2025-02-04"
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Download data

Sample 200 sample IDs from the Zeevi et al., dataset (PRJEB11532)

```
{ head -n 1 PRJEB11532_ena_meta.tsv; tail -n +2 PRJEB11532_ena_meta.tsv | shuf -n 200; } > subsample200_PRJEB11532_ena_meta.tsv
cut -f1 subsample200_PRJEB11532_ena_meta.tsv > subsample200_PRJEB11532_ids.tsv


kingfisher get --run-identifiers-list subsample200_PRJEB11532_ids.tsv --download-threads 5 -m ena-ascp ena-ftp aws-http prefetch
```

### Run Sylph

Run Sylph (v0.8.0) in 'query' mode using the GTDB 99% identity dataset.

```
sylph query gtdb_ordered_99.syldb -u --read-seq-id 99.9 -t 100  -1 ./*_1.fastq.gz -2 ./*_2.fastq.gz -o ./zeevi_PRJEB11532_query_gtdb_220_id99.tsv ./ERR*[0-9][0-9].fastq.gz
```

```
sylph query /data1/gerryt/sylph_analyses/gtdb_98_ordered_DB/gtdb_ordered_98.syldb -u --read-seq-id 99.9 -t 25  -1 ./*_1.fastq.gz -2 ./*_2.fastq.gz -o ./zeevi_PRJEB11532_query_gtdb_220_id98.tsv ./ERR*[0-9][0-9].fastq.gz
```

```
sylph profile /data1/gerryt/sylph_analyses/gtdb_98_ordered_DB/gtdb_ordered_98.syldb -u --read-seq-id 99.9 -t 25  -1 ./*_1.fastq.gz -2 ./*_2.fastq.gz -o ./zeevi_PRJEB11532_profile_gtdb_220_id98.tsv ./ERR*[0-9][0-9].fastq.gz
```

```
sylph profile /data1/gerryt/sylph_analyses/gtdb-r220-c200-dbv1.syldb -u --read-seq-id 99.9 -t 25  -1 ./*_1.fastq.gz -2 ./*_2.fastq.gz -o ./zeevi_PRJEB11532_profile_gtdb_220_id95.tsv ./ERR*[0-9][0-9].fastq.gz
```

```
sylph query /data1/gerryt/sylph_analyses/gtdb-r220-c200-dbv1.syldb -u --read-seq-id 99.9 -t 25  -1 ./*_1.fastq.gz -2 ./*_2.fastq.gz -o ./zeevi_PRJEB11532_query_gtdb_220_id95.tsv ./ERR*[0-9][0-9].fastq.gz
```


### Load data and prepare for simulations

```{r}
library(strainspy)

# Load Zeevi the GTDB 99% identity dataset
# data <- read_sylph("~/Documents/strainspy_manuscript/zeevi/zeevi_PRJEB11532_query_gtdb_220_id99.tsv.gz")
data <- read_sylph("TEST_DATA/zeevi/zeevi_PRJEB11532_query_gtdb_220_id99.tsv.gz")
data <- filter_by_presence(data, min_nonzero = 150)

# Get the ids of cases after a random split
set.seed(789)
cascon = rbinom(round(SummarizedExperiment::ncol(data)),  1, 0.5)
cases = which(cascon == 1)

# setup metadata
meta_data = data.frame(run_accession = colnames(data),
                       Case_status = cascon)

meta_data$Case_status <- factor(meta_data$Case_status)
data = strainspy:::modify_metadata(se = data, meta_data = meta_data)
```

## Sensitivity Analysis
```{r}
# randomly select 100 entries to rescale abundance - ensure omit NA from cascon model
fit_cascon_null = readRDS("TEST_DATA/zeevi/TEMP_FITS/null_cascon.rds")
set.seed(789)
sel = sample(which(!is.na(fit_cascon_null@coefficients$X.Intercept.)), 100)
contigs = data@elementMetadata$Contig_name[sel]

# fit the 3 models using update option
fit_ob_null = readRDS("TEST_DATA/zeevi/TEMP_FITS/null_ob.rds")
fit_zib_null = readRDS("TEST_DATA/zeevi/TEMP_FITS/null_zib.rds")

```

### Simulate changes in identity
```{r}
# run through by varying beta
scale_factors = c(seq(0.965, 0.995, by = 0.005),0.999,1)
op = data.frame()
for(scale_factor in scale_factors){
  exp_beta = c()
  exp_zi = c()
  se = data # NULL
  
  data_matrix <- SummarizedExperiment::assay(se) # NULL
  vals_to_mod = data_matrix[sel, cases]
  
  for(i in 1:length(sel)){ 
    tmp = rescale_beta(x = data_matrix[sel[i], cases]/100,
                       beta = scale_factor,
                       zi = 0)
    
    vals_to_mod[i,] = tmp$rescaled*100
    exp_beta[i] = tmp$expected_beta
    exp_zi[i] = tmp$expected_zi
  }
  
  # add modified counts for cases
  data_matrix[sel, cases] = vals_to_mod
  
  # add modified assay back to se
  SummarizedExperiment::assay(se) <- data_matrix
  
  fit_zib_updated = strainspy:::update_fit(fit = fit_zib_null, se = se, update_idx = sel, nthreads = 10)
  fit_ob_updated = strainspy:::update_fit(fit = fit_ob_null, se = se, update_idx = sel, nthreads = 10)
  fit_cascon_updated = strainspy:::update_fit(fit = fit_cascon_null, se = se, update_idx = sel, nthreads = 10)
  cat(scale_factor, "\n")
  
  op = rbind(op, 
             cbind(scale_factor, 
                   rbind(
                     c("zib", strainspy:::get_confusion_mx(top_hits = top_hits(fit_zib_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                     c("ob", strainspy:::get_confusion_mx(top_hits = top_hits(fit_ob_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                     c("cc", strainspy:::get_confusion_mx(top_hits = top_hits(fit_cascon_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)))))
}

colnames(op) = c("sf", "test", "tp", "fn", "fp", "tn")


```

### Simulate changes in presence/absence
```{r}
zero_props = seq(0.2, 0.72, by = 0.05)
op = data.frame()
for(zero_prop in zero_props){
  exp_beta = c()
  exp_zi = c()
  se = data # NULL
  
  data_matrix <- SummarizedExperiment::assay(se) # NULL
  vals_to_mod = data_matrix[sel, cases]
  
  for(i in 1:length(sel)){ 
    tmp = rescale_beta(x = data_matrix[sel[i], cases]/100,
                       beta = 1,
                       zi = zero_prop)
    
    vals_to_mod[i,] = tmp$rescaled*100
    exp_beta[i] = tmp$expected_beta
    exp_zi[i] = tmp$expected_zi
  }
  
  # add modified counts for cases
  data_matrix[sel, cases] = vals_to_mod
  
  # add modified assay back to se
  SummarizedExperiment::assay(se) <- data_matrix
  
  fit_zib_updated = strainspy:::update_fit(fit = fit_zib_null, se = se, update_idx = sel, nthreads = 10)
  fit_ob_updated = strainspy:::update_fit(fit = fit_ob_null, se = se, update_idx = sel, nthreads = 10)
  fit_cascon_updated = strainspy:::update_fit(fit = fit_cascon_null, se = se, update_idx = sel, nthreads = 10)
  cat(zero_prop, "\n")
  
  op = rbind(op, 
             cbind(zero_prop, 
                   rbind(
                     c("zib", strainspy:::get_confusion_mx(top_hits = top_hits(fit_zib_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                     c("ob", strainspy:::get_confusion_mx(top_hits = top_hits(fit_ob_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                     c("cc", strainspy:::get_confusion_mx(top_hits = top_hits(fit_cascon_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)))))
}

colnames(op) = c("z_prop", "test", "tp", "fn", "fp", "tn")
```


### Simulate both identity and presence/absence changes
```{r}
zero_props = seq(0, 0.72, by = 0.05)
scale_factors = c(seq(0.95, 0.995, by = 0.005),0.999,1)
op = data.frame()

for(scale_factor in scale_factors){
  for(zero_prop in zero_props){
    
    t0 = Sys.time()
    
    exp_beta = c()
    exp_zi = c()
    se = data # NULL
    
    data_matrix <- SummarizedExperiment::assay(se) # NULL
    vals_to_mod = data_matrix[sel, cases]
    
    for(i in 1:length(sel)){ 
      tmp = rescale_beta(x = data_matrix[sel[i], cases]/100,
                         beta = scale_factor,
                         zi = zero_prop)
      
      vals_to_mod[i,] = tmp$rescaled*100
      exp_beta[i] = tmp$expected_beta
      exp_zi[i] = tmp$expected_zi
    }
    
    # add modified counts for cases
    data_matrix[sel, cases] = vals_to_mod
    
    # add modified assay back to se
    SummarizedExperiment::assay(se) <- data_matrix
    
    fit_zib_updated = strainspy:::update_fit(fit = fit_zib_null, se = se, update_idx = sel, nthreads = 10)
    fit_ob_updated = strainspy:::update_fit(fit = fit_ob_null, se = se, update_idx = sel, nthreads = 10)
    fit_cascon_updated = strainspy:::update_fit(fit = fit_cascon_null, se = se, update_idx = sel, nthreads = 10)
    cat("eval_time (min) =", Sys.time() - t0, "sf =", scale_factor, "zp =",  zero_prop, "\n")
    
    op = rbind(op, 
               cbind(zero_prop, scale_factor,
                     rbind(
                       c("zib", strainspy:::get_confusion_mx(top_hits = top_hits(fit_zib_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                       c("ob", strainspy:::get_confusion_mx(top_hits = top_hits(fit_ob_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)),
                       c("cc", strainspy:::get_confusion_mx(top_hits = top_hits(fit_cascon_updated), gt_contigs = contigs, all_contigs = rownames(se), print_cm = T)))))
  }
}
colnames(op) = c("zero_prop", "scale_factor", "test", "tp", "fn", "fp", "tn")
op$tp = as.numeric(op$tp)
op$fn = as.numeric(op$fn)
op$fp = as.numeric(op$fp)
op$tn = as.numeric(op$tn)

# Generate a manhattan plot with ground truth
strainspy:::plot_manhattan_gt(fit_zib_updated, method = "holm", ground_truth = contigs)

```
### Generate sensitivity heatmaps
```{r}
library(ggplot2)
library(dplyr)
library(viridis)

op$sensitivity = as.numeric(op$tp) / (as.numeric(op$tp) +  (as.numeric(op$tn) - as.numeric(op$fp)) )*100
op$test <- factor(op$test)

saveRDS(op, "TEST_DATA/zeevi/TEMP_FITS/test_op.rds")

ggplot(op, aes(x = zero_prop, y = scale_factor, fill = sensitivity)) +
  geom_tile() +
  scale_fill_viridis_c(name = "Sensitivity") +  # Viridis color scale
  facet_wrap(~ test) +  # Separate plots for each test
  labs(
    x = "Zero Proportion",
    y = "Scale Factor",
    # title = "Sensitivity Across Tests"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),  # Styling facet labels
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels if needed
  )

ggplot(op, aes(x = zero_prop, y = scale_factor, fill = fp)) +
  geom_tile() +
  scale_fill_viridis_c(name = "False Positives") +  # Viridis color scale
  facet_wrap(~ test) +  # Separate plots for each test
  labs(
    x = "Zero Proportion",
    y = "Scale Factor",
    # title = "Sensitivity Across Tests"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),  # Styling facet labels
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels if needed
  )


```

## Simulate variation in ANI with microbial load

Microbial load was predicted using https://github.com/grp-bork/microbial_load_predictor.
```{r}
mic_load = readRDS("TEST_DATA/zeevi/microbial_load.rds")

# This is somewhat arbitrary, but should work for simluations
mic_load$color = "green"
mic_load$color[mic_load$load < 6.25e10] = "blue"
mic_load$color[mic_load$load > 9e10] = "red"
plot(sort( log10(mic_load$load) ), col = sort(mic_load$color))

meta_data$microbial_load_raw = mic_load$load[match(meta_data$run_accession, mic_load$sampleID)]

meta_data$microbial_load_HML = "M"
meta_data$microbial_load_HML[meta_data$microbial_load_raw > 9e10] = "H"
meta_data$microbial_load_HML[meta_data$microbial_load_raw < 6.25e10] = "L"
meta_data$microbial_load_HML = factor(meta_data$microbial_load_HML, levels = c("L", "M", "H"))


meta_data$microbial_load = (meta_data$microbial_load_raw - min(meta_data$microbial_load_raw))/ (max(meta_data$microbial_load_raw) - min(meta_data$microbial_load_raw)) 

data = strainspy:::modify_metadata(se = data, meta_data = meta_data)

# Use load as a predictor (numeric/normalised)
load_zib_fit = glmZiBFit(data,  as.formula('~microbial_load'), nthreads = 10)
load_ob_fit = glmFit(data,  as.formula('~microbial_load'), nthreads = 10)

# Keep high/medium/low 0/0.5/1 (factor)
loadHML_zib_fit = glmZiBFit(data,  as.formula('~microbial_load_HML'), nthreads = 10)
loadHML_ob_fit = glmFit(data,  as.formula('~microbial_load_HML'), nthreads = 10)

# Generate a violin plot for all hits
s1 = top_hits(load_zib_fit)$Contig_name
s2 = top_hits(load_ob_fit)$Contig_name
s3 = top_hits(loadHML_zib_fit)$Contig_name
s4 = top_hits(loadHML_ob_fit)$Contig_name

contig_names = c("Flavonifractor sp. DFI.6.63", "Lachnospiraceae bacterium HGM11888",
                 "Lachnospiraceae bacterium BBMGS-G02-107", "Lachnospiraceae bacterium AM48-27BH AM48-27BH.Scaf1",
                 "Lachnospiraceae bacterium AF58-1A AF58-1A.Scaf1", "Eubacteriales (uncult) ERR9762703",
                 "Oscillibacter valericigenes DFI.6.76", "Oscillibacter sp. (uncult) ERR1600659",
                 "Clostridiales bacterium HRGM_Genome_2357", "Lachnospiraceae (uncult) ERR1430444",
                 "Lachnospiraceae bacterium AM48-27BH", "Bacteroides fragilis 1001271B",
                 "Bacteroides sp. PHL 2737")

strainspy:::plot_violin(data, 'microbial_load_HML', unique(union(union(union(s1,s2), s3), s4)), contig_names, drop_ANI_zeros = T)

# How bad is abundance in comparison?
# mp_files = dir("TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/", pattern = "*_profiled.tsv", full.names = T)
# strainspy::merge_metaphlan_files(metaphlan_files = mp_files, output_folder = "TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/")
mp_sgb = strainspy::read_metaphlan("TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/metaphlan_merged.tsv.gz")

# use the gtdb database for easier comparisons
# merge_metaphlan_files(dir("TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/", "*gtdb.tsv", full.names = T), output_folder = "TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/", output_filename = "gtdb", sgb_database = F)
mp_gtdb = strainspy::read_metaphlan("TEST_DATA/zeevi/mpa_vJun23_CHOCOPhlAnSGB_202307/gtdb_merged.tsv.gz")


mp <- mp_gtdb
mp <- filter_by_presence(mp, min_nonzero = 5, rescale_abundance = T)
# meta_data needs to be renamed
meta_data_mp = meta_data
meta_data_mp$run_accession = paste(gsub("_1$", "", meta_data_mp$run_accession), "_profiled_gtdb", sep = "")
meta_data_mp = meta_data_mp[unname(sapply(colnames(mp), function(x) which(x == meta_data_mp$run_accession))),]
all(meta_data_mp$run_accession == colnames(mp)) # check

mp = strainspy:::modify_metadata(se = mp, meta_data = meta_data_mp)
# Use load as a predictor (numeric/normalised)
load_zib_mp_fit = glmZiBFit(mp,  as.formula('~microbial_load'), nthreads = 10)
load_ob_mp_fit = glmFit(mp,  as.formula('~microbial_load'), nthreads = 10)

# Keep high/medium/low 0/0.5/1 (factor)
loadHML_zib_mp_fit = glmZiBFit(mp,  as.formula('~microbial_load_HML'), nthreads = 10)
loadHML_ob_mp_fit = glmFit(mp,  as.formula('~microbial_load_HML'), nthreads = 10)


s1 = top_hits(load_zib_mp_fit)$Contig_name
s2 = top_hits(load_ob_mp_fit)$Contig_name
s3 = top_hits(loadHML_zib_mp_fit)$Contig_name
s4 = top_hits(loadHML_ob_mp_fit)$Contig_name

# strainspy:::plot_violin(mp, 'microbial_load_HML', unique(union(union(union(s1,s2), s3), s4)), drop_ANI_zeros = T)
strainspy:::plot_violin(mp, 'microbial_load_HML',s2, drop_ANI_zeros = T)

# Simulation steps:
# Vary identity of 1000 randomly selected features
# Ensure we are not picking cascon NAs 
fit_cascon_null = readRDS("TEST_DATA/zeevi/TEMP_FITS/null_cascon.rds")
set.seed(789)
sel_1 = sample(which(!is.na(fit_cascon_null@coefficients$X.Intercept.)), 1000)

# we will vary the identity of these 1000 features as follows:
# Green isolates, scale_factor = 0.25
# Green isolates, scale_factor = 0.25
# Green isolates, scale_factor = 0.25


# Randomly select 100 of these to vary with case/control status
set.seed(789)
sel = sample(sel_1, 100)
contigs = data@elementMetadata$Contig_name[sel]


```